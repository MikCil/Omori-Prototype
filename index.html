<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Interfaccia Interattiva Omori</title>
  <style>
    @font-face {
      font-family: 'OmoriFont';
      src: url('OMORI_GAME2.ttf') format('truetype');
      font-weight: normal;
      font-style: normal;
    }
    
    body {
      font-family: 'OmoriFont', sans-serif;
      margin: 0;
      padding: 0;
      background-image: url('images/background.png');
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
      color: white;
      text-align: center; /* Center content like the selector */
    }

    /* --- NEW STYLES FOR POST SELECTOR --- */
    #selector-container {
      padding: 20px;
      background-color: rgba(0, 0, 0, 0.5);
    }

    #postSelector {
      font-family: 'OmoriFont', sans-serif;
      font-size: 1em;
      background: #000000;
      color: white;
      border: 2px solid #ffffff;
      padding: 5px;
      min-width: 400px;
      max-width: 80%;
    }
    /* --- END OF NEW STYLES --- */
    
    #container {
      position: relative;
      width: 800px;
      height: 800px;
      background-color: transparent;
      border: none;
      cursor: pointer;
      overflow: visible;
      margin: 20px auto;
    }
    
    .big-omori {
      position: absolute;
      width: 400px;
      height: auto;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      z-index: 5;
    }
    
    .bubble {
      position: absolute;
      background: #000000;
      border: 2px solid #ffffff;
      border-radius: 3px;
      padding: 15px;
      max-width: 220px;
      font-size: 1em;
      z-index: 10;
      color: white;
      box-shadow: 4px 4px 0px rgba(0, 0, 0, 0.5);
      text-align: left; /* Keep text in bubbles left-aligned */
    }
    
    .comment-container {
      position: absolute;
      z-index: 10;
    }
    
    @keyframes slideFromRight {
      from { transform: translateX(100px); opacity: 0; }
      to { transform: translateX(0); opacity: 1; }
    }
    
    @keyframes slideFromLeft {
      from { transform: translateX(-100px); opacity: 0; }
      to { transform: translateX(0); opacity: 1; }
    }
    
    .slide-right {
      animation: slideFromRight 0.8s ease-out forwards;
    }
    
    .slide-left {
      animation: slideFromLeft 0.8s ease-out forwards;
    }
    
    .comment-img {
      position: absolute;
      width: 200px;
      height: 200px;
      border: none;
      border-radius: 0;
      object-fit: cover;
      z-index: 11;
    }
    
    .comment-container:not(.left) .comment-img {
      left: 0;
    }
    
    .comment-container.left .comment-img {
      right: 0;
    }
    
    .comment-bubble {
      position: absolute;
      background: #000000;
      border: 2px solid #ffffff;
      border-radius: 3px;
      padding: 15px;
      width: 200px;
      font-size: 1em;
      color: white;
      box-shadow: 4px 4px 0px rgba(0, 0, 0, 0.5);
      text-align: left; /* Keep text in bubbles left-aligned */
    }
    
    .comment-container:not(.left) .comment-bubble {
      left: 210px;
    }
    
    .comment-container.left .comment-bubble {
      right: 210px;
    }
    
    .character-name {
      position: absolute;
      top: -30px;
      left: 0;
      background: #000000;
      border: 2px solid #ffffff;
      padding: 2px 8px;
      font-size: 0.9em;
      color: white;
      text-transform: uppercase;
      font-weight: bold;
    }
    
    .typing-text {
      display: inline;
      white-space: pre-wrap;
    }
  </style>
</head>
<body>
  <audio id="backgroundMusic" autoplay loop preload="auto">
    <source src="soundtrack.mp3" type="audio/mp3">
    Your browser does not support the audio element.
  </audio>
  
  <!-- NEW: Container for the post selector -->
  <div id="selector-container">
    <label for="postSelector">Choose a Post:</label>
    <select id="postSelector">
      <option>Loading posts...</option>
    </select>
  </div>

  <div id="container">
    <img id="bigOmori" src="images/omoriknife.gif" alt="Omori Knife" class="big-omori">
  </div>

  <script>
    // --- AUDIO HANDLING (Unchanged) ---
    const backgroundMusic = document.getElementById('backgroundMusic');
    backgroundMusic.loop = true;
    backgroundMusic.addEventListener('ended', function() {
      this.currentTime = 0;
      this.play();
    }, false);
    window.addEventListener('load', function() {
      backgroundMusic.play().catch(function(error) {
        console.log("Audio autoplay was prevented. User interaction needed.");
      });
    });
    document.addEventListener('click', function() {
      if (backgroundMusic.paused) {
        backgroundMusic.play();
      }
    });

    // --- DATA AND CONSTANTS (Unchanged) ---
    const characterNames = ["KEL", "HERO", "MARI", "KEL", "AUBREY", "BASIL"];
    const commentPositions = [
      { top: "10%", left: "50%" },
      { top: "40%", left: "69%" },
      { top: "70%", left: "50%" },
      { top: "70%", left: "30%" },
      { top: "40%", left: "23%" },
      { top: "10%", left: "30%" }
    ];
    const commentGifs = [
      "kelbackflip.gif", "herogun.gif", "mari2.gif",
      "kelbroken.gif", "aubrey.gif", "basil.gif"
    ];
    
    // --- STATE MANAGEMENT (Slightly modified) ---
    let allPosts = []; // Will hold all data from JSON
    let currentPostIndex = 0;
    let currentCommentIndex = 0;
    let state = "ready";
    let typingInProgress = false;
    
    const container = document.getElementById("container");
    const bigOmori = document.getElementById("bigOmori");
    const postSelector = document.getElementById("postSelector");
    
    let postBubbleElement = null;

    // --- NEW: DATA LOADING AND INITIALIZATION ---
    document.addEventListener('DOMContentLoaded', () => {
      fetch('omori_posts.json')
        .then(response => {
          if (!response.ok) {
            throw new Error('Network response was not ok ' + response.statusText);
          }
          return response.json();
        })
        .then(data => {
          // Process raw data into the simpler format used by the display functions
          allPosts = data.map(post => {
              // Combine title and selftext for the main post content
              const postContent = `${post.title}\n\n${post.selftext || ''}`.trim();
              
              // Flatten all comments and sub-comments (if any) into a single array of strings
              // For now, it just takes top-level comments as per your example.
              const comments = post.comments.map(comment => comment.body);

              return { post: postContent, comments: comments };
          });
          
          populatePostSelector();
          console.log("Successfully loaded and processed " + allPosts.length + " posts.");
        })
        .catch(error => {
          console.error('Error loading or parsing JSON:', error);
          postSelector.innerHTML = '<option>Error loading posts.</option>';
        });
    });

    // --- NEW: Function to populate the dropdown selector ---
    function populatePostSelector() {
      postSelector.innerHTML = ''; // Clear "Loading..." message
      allPosts.forEach((postData, index) => {
        const option = document.createElement('option');
        option.value = index;
        // Truncate long titles for better display
        const title = postData.post.split('\n\n')[0];
        option.textContent = title.length > 80 ? title.substring(0, 80) + '...' : title;
        postSelector.appendChild(option);
      });
    }

    // --- NEW: Event listener for the selector ---
    postSelector.addEventListener('change', (event) => {
      currentPostIndex = parseInt(event.target.value, 10);
      resetContainer(); // Clear the screen
      state = 'ready';    // Set state to ready for the next click
      console.log(`Switched to post index: ${currentPostIndex}`);
    });
    
    // --- DISPLAY FUNCTIONS (Mostly Unchanged) ---
    
    function typeText(element, text, index = 0, callback) {
      if (index < text.length) {
        typingInProgress = true;
        element.textContent = text.substring(0, index + 1);
        setTimeout(() => typeText(element, text, index + 1, callback), 20); // Slightly faster typing
      } else {
        typingInProgress = false;
        if (callback) callback();
      }
    }
    
    function showPost() {
      const currentPost = allPosts[currentPostIndex];
      postBubbleElement = document.createElement("div");
      postBubbleElement.classList.add("bubble");
      postBubbleElement.style.top = "calc(30% - 120px)";
      postBubbleElement.style.left = "50%";
      postBubbleElement.style.transform = "translateX(-50%)";
      
      const nameLabel = document.createElement("div");
      nameLabel.classList.add("character-name");
      nameLabel.textContent = "OMORI";
      postBubbleElement.appendChild(nameLabel);
      
      const textElement = document.createElement("div");
      textElement.classList.add("typing-text");
      postBubbleElement.appendChild(textElement);
      
      container.appendChild(postBubbleElement);
      
      typeText(textElement, currentPost.post);
    }
    
    function addComment(commentText) {
      const commentContainer = document.createElement("div");
      commentContainer.classList.add("comment-container");
      
      const positionIndex = currentCommentIndex % commentPositions.length;

      if (positionIndex >= 3) {
        commentContainer.classList.add("left", "slide-left");
      } else {
        commentContainer.classList.add("slide-right");
      }
    
      const pos = commentPositions[positionIndex];
      commentContainer.style.top = pos.top;
      commentContainer.style.left = pos.left;
      
      const commentImg = document.createElement("img");
      const gifIndex = currentCommentIndex % commentGifs.length;
      commentImg.src = "images/" + commentGifs[gifIndex];
      commentImg.alt = "Comment Character";
      commentImg.classList.add("comment-img");
    
      const commentBubble = document.createElement("div");
      commentBubble.classList.add("comment-bubble");
      
      const nameLabel = document.createElement("div");
      nameLabel.classList.add("character-name");
      nameLabel.textContent = characterNames[gifIndex];
      commentBubble.appendChild(nameLabel);
      
      const textElement = document.createElement("div");
      textElement.classList.add("typing-text");
      commentBubble.appendChild(textElement);
      
      commentContainer.appendChild(commentImg);
      commentContainer.appendChild(commentBubble);
      container.appendChild(commentContainer);
      
      typeText(textElement, commentText);
      
      currentCommentIndex++;
    }
    
    function resetContainer() {
      // If there are more than 6 comments, we don't remove them all, just the bubble
      // This function should clear everything except the main Omori character
      const children = Array.from(container.children);
      children.forEach(child => {
        if (child.id !== "bigOmori") {
          container.removeChild(child);
        }
      });
      currentCommentIndex = 0; // Reset comment index for the new post
      if (postBubbleElement) postBubbleElement = null;
    }
    
    // --- MAIN CLICK HANDLER (Slightly modified to use `allPosts`) ---
    container.addEventListener("click", function(){
      if (typingInProgress || allPosts.length === 0) {
        return; // Don't do anything if typing or if data hasn't loaded
      }
      
      if (state === "ready") {
        showPost();
        state = "postDisplayed";
      } else if (state === "postDisplayed") {
        if (postBubbleElement) {
          container.removeChild(postBubbleElement);
          postBubbleElement = null;
        }
        
        // Before showing comments, clear previous comments if any
        resetContainer();

        const currentPost = allPosts[currentPostIndex];
        if (currentPost.comments.length > 0) {
          addComment(currentPost.comments[0]);
          state = "commentInProgress";
        } else {
          // No comments, stay ready for the next post selection
          state = "ready";
        }
      } else if (state === "commentInProgress") {
        const currentPost = allPosts[currentPostIndex];
        if (currentCommentIndex < currentPost.comments.length) {
          // If we have shown 6 comments, clear them before showing the next batch
          if (currentCommentIndex > 0 && currentCommentIndex % 6 === 0) {
              resetContainer();
          }
          addComment(currentPost.comments[currentCommentIndex]);
        } else {
          // All comments shown for this post, reset the view
          resetContainer();
          state = "ready";
        }
      }
    });
  </script>
</body>
</html>
