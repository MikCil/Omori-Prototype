<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Interfaccia Interattiva Omori</title>
  <style>
    @font-face {
      font-family: 'OmoriFont';
      src: url('OMORI_GAME2.ttf') format('truetype');
      font-weight: normal;
      font-style: normal;
    }
    
    body {
      font-family: 'OmoriFont', sans-serif;
      margin: 0;
      padding: 0;
      background-image: url('images/background.png');
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
      color: white;
      text-align: center;
    }

    #selector-container {
      padding: 20px;
      background-color: rgba(0, 0, 0, 0.5);
    }

    #postSelector {
      font-family: 'OmoriFont', sans-serif;
      font-size: 1em;
      background: #000000;
      color: white;
      border: 2px solid #ffffff;
      padding: 5px;
      min-width: 400px;
      max-width: 80%;
    }
    
    #container {
      position: relative;
      width: 800px;
      height: 800px;
      background-color: transparent;
      border: none;
      cursor: pointer;
      overflow: visible;
      margin: 20px auto;
    }
    
    .big-omori {
      position: absolute;
      width: 400px;
      height: auto;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      z-index: 5;
    }
    
    .bubble {
      position: absolute;
      background: #000000;
      border: 2px solid #ffffff;
      border-radius: 3px;
      padding: 15px;
      z-index: 10;
      color: white;
      box-shadow: 4px 4px 0px rgba(0, 0, 0, 0.5);
      text-align: left;
      /* --- MODIFIED: Fixed size and larger font --- */
      width: 300px;
      height: 200px;
      font-size: 1.5em;
      overflow: hidden;
      box-sizing: border-box;
    }
    
    .comment-container {
      position: absolute;
      z-index: 10;
    }
    
    @keyframes slideFromRight {
      from { transform: translateX(100px); opacity: 0; }
      to { transform: translateX(0); opacity: 1; }
    }
    
    @keyframes slideFromLeft {
      from { transform: translateX(-100px); opacity: 0; }
      to { transform: translateX(0); opacity: 1; }
    }
    
    .slide-right {
      animation: slideFromRight 0.8s ease-out forwards;
    }
    
    .slide-left {
      animation: slideFromLeft 0.8s ease-out forwards;
    }
    
    .comment-img {
      position: absolute;
      width: 200px;
      height: 200px;
      border: none;
      border-radius: 0;
      object-fit: cover;
      z-index: 11;
    }
    
    .comment-container:not(.left) .comment-img {
      left: 0;
    }
    
    .comment-container.left .comment-img {
      right: 0;
    }
    
    .comment-bubble {
      position: absolute;
      background: #000000;
      border: 2px solid #ffffff;
      border-radius: 3px;
      padding: 15px;
      color: white;
      box-shadow: 4px 4px 0px rgba(0, 0, 0, 0.5);
      text-align: left;
      /* --- MODIFIED: Fixed size and larger font --- */
      width: 250px;
      height: 150px;
      font-size: 1.5em;
      overflow: hidden;
      box-sizing: border-box;
    }
    
    .comment-container:not(.left) .comment-bubble {
      left: 210px;
    }
    
    .comment-container.left .comment-bubble {
      right: 210px;
    }
    
    .character-name {
      position: absolute;
      top: -30px;
      left: 0;
      background: #000000;
      border: 2px solid #ffffff;
      padding: 2px 8px;
      font-size: 0.9em;
      color: white;
      text-transform: uppercase;
      font-weight: bold;
    }
    
    .typing-text {
      display: inline;
      white-space: pre-wrap;
    }
  </style>
</head>
<body>
  <audio id="backgroundMusic" autoplay loop preload="auto">
    <source src="soundtrack.mp3" type="audio/mp3">
    Your browser does not support the audio element.
  </audio>
  
  <div id="selector-container">
    <label for="postSelector">Choose a Post:</label>
    <select id="postSelector">
      <option>Loading posts...</option>
    </select>
  </div>

  <div id="container">
    <img id="bigOmori" src="images/omoriknife.gif" alt="Omori Knife" class="big-omori">
  </div>

  <script>
    // --- AUDIO HANDLING (Unchanged) ---
    const backgroundMusic = document.getElementById('backgroundMusic');
    backgroundMusic.loop = true;
    backgroundMusic.addEventListener('ended', function() { this.currentTime = 0; this.play(); }, false);
    window.addEventListener('load', () => { backgroundMusic.play().catch(e => console.log("Autoplay prevented.")); });
    document.addEventListener('click', () => { if (backgroundMusic.paused) backgroundMusic.play(); });

    // --- CONFIGURATION & CONSTANTS ---
    const CHARS_PER_PAGE = 200; // Tweak this value to change text amount per page
    const characterNames = ["KEL", "HERO", "MARI", "KEL", "AUBREY", "BASIL"];
    const commentPositions = [
      { top: "10%", left: "50%" }, { top: "40%", left: "69%" }, { top: "70%", left: "50%" },
      { top: "70%", left: "30%" }, { top: "40%", left: "23%" }, { top: "10%", left: "30%" }
    ];
    const commentGifs = [
      "kelbackflip.gif", "herogun.gif", "mari2.gif",
      "kelbroken.gif", "aubrey.gif", "basil.gif"
    ];
    
    // --- STATE MANAGEMENT ---
    let allPosts = [];
    let currentPostIndex = 0;
    let currentCommentIndex = 0;
    let currentPostPage = 0; // NEW: Tracks current page of the post
    let currentCommentPage = 0; // NEW: Tracks current page of the comment
    let state = "ready"; // Can be: ready, postInProgress, commentInProgress
    let typingInProgress = false;
    
    const container = document.getElementById("container");
    const postSelector = document.getElementById("postSelector");
    
    // --- DATA LOADING & INITIALIZATION ---
    document.addEventListener('DOMContentLoaded', () => {
      fetch('omori_posts.json')
        .then(response => response.json())
        .then(data => {
          allPosts = data.map(post => ({
              post: `${post.title}\n\n${post.selftext || ''}`.trim(),
              comments: post.comments.map(comment => comment.body)
          }));
          populatePostSelector();
        })
        .catch(error => {
          console.error('Error loading JSON:', error);
          postSelector.innerHTML = '<option>Error loading posts.</option>';
        });
    });

    function populatePostSelector() {
      postSelector.innerHTML = '';
      allPosts.forEach((postData, index) => {
        const option = document.createElement('option');
        option.value = index;
        const title = postData.post.split('\n\n')[0];
        option.textContent = title.length > 80 ? title.substring(0, 80) + '...' : title;
        postSelector.appendChild(option);
      });
    }

    postSelector.addEventListener('change', (event) => {
      currentPostIndex = parseInt(event.target.value, 10);
      resetForNewPost();
    });
    
    // --- DISPLAY FUNCTIONS (Modified for Pagination) ---
    
    function typeText(element, text, index = 0, callback) {
      if (index < text.length) {
        typingInProgress = true;
        element.textContent = text.substring(0, index + 1);
        setTimeout(() => typeText(element, text, index + 1, callback), 10); // MODIFIED: Faster typing
      } else {
        typingInProgress = false;
        if (callback) callback();
      }
    }
    
    function showPost() {
      // Clear any previous post bubble
      const existingBubble = document.querySelector('.bubble');
      if (existingBubble) container.removeChild(existingBubble);

      const currentPost = allPosts[currentPostIndex];
      const start = currentPostPage * CHARS_PER_PAGE;
      let textToShow = currentPost.post.substring(start, start + CHARS_PER_PAGE);

      // Check if there's more text to show on the next page
      if (start + CHARS_PER_PAGE < currentPost.post.length) {
        textToShow += "... (click to continue)";
      }

      const postBubbleElement = document.createElement("div");
      postBubbleElement.classList.add("bubble");
      postBubbleElement.style.top = "calc(20% - 120px)";
      postBubbleElement.style.left = "50%";
      postBubbleElement.style.transform = "translateX(-50%)";
      
      const nameLabel = document.createElement("div");
      nameLabel.classList.add("character-name");
      nameLabel.textContent = "OMORI";
      postBubbleElement.appendChild(nameLabel);
      
      const textElement = document.createElement("div");
      textElement.classList.add("typing-text");
      postBubbleElement.appendChild(textElement);
      
      container.appendChild(postBubbleElement);
      typeText(textElement, textToShow);
    }
    
    function addComment() {
      const currentPost = allPosts[currentPostIndex];
      const commentText = currentPost.comments[currentCommentIndex];

      const start = currentCommentPage * CHARS_PER_PAGE;
      let textToShow = commentText.substring(start, start + CHARS_PER_PAGE);

      if (start + CHARS_PER_PAGE < commentText.length) {
          textToShow += "... (click to continue)";
      }

      // Clear the specific comment we might be re-drawing
      const positionIndex = currentCommentIndex % commentPositions.length;
      const existingCommentContainer = document.querySelector(`.comment-container[data-position-index='${positionIndex}']`);
      if (existingCommentContainer) container.removeChild(existingCommentContainer);

      const commentContainer = document.createElement("div");
      commentContainer.classList.add("comment-container");
      commentContainer.dataset.positionIndex = positionIndex; // For easy selection later

      if (positionIndex >= 3) commentContainer.classList.add("left", "slide-left");
      else commentContainer.classList.add("slide-right");
    
      const pos = commentPositions[positionIndex];
      commentContainer.style.top = pos.top;
      commentContainer.style.left = pos.left;
      
      const commentImg = document.createElement("img");
      const gifIndex = currentCommentIndex % commentGifs.length;
      commentImg.src = "images/" + commentGifs[gifIndex];
      commentImg.alt = "Comment Character";
      commentImg.classList.add("comment-img");
    
      const commentBubble = document.createElement("div");
      commentBubble.classList.add("comment-bubble");
      
      const nameLabel = document.createElement("div");
      nameLabel.classList.add("character-name");
      nameLabel.textContent = characterNames[gifIndex];
      commentBubble.appendChild(nameLabel);
      
      const textElement = document.createElement("div");
      textElement.classList.add("typing-text");
      commentBubble.appendChild(textElement);
      
      commentContainer.appendChild(commentImg);
      commentContainer.appendChild(commentBubble);
      container.appendChild(commentContainer);
      
      typeText(textElement, textToShow);
    }
    
    function resetContainer() {
      const children = Array.from(container.children);
      children.forEach(child => {
        if (child.id !== "bigOmori") container.removeChild(child);
      });
    }

    function resetForNewPost() {
        resetContainer();
        state = 'ready';
        currentPostPage = 0;
        currentCommentIndex = 0;
        currentCommentPage = 0;
    }
    
    // --- MAIN CLICK HANDLER (Rewritten for Pagination) ---
    container.addEventListener("click", function(){
      if (typingInProgress || allPosts.length === 0) return;
      
      const currentPostData = allPosts[currentPostIndex];

      if (state === "ready") {
        currentPostPage = 0;
        showPost();
        state = "postInProgress";

      } else if (state === "postInProgress") {
        const hasMorePostText = (currentPostPage + 1) * CHARS_PER_PAGE < currentPostData.post.length;
        if (hasMorePostText) {
          currentPostPage++;
          showPost();
        } else {
          // Post finished, move to comments
          resetContainer();
          if (currentPostData.comments.length > 0) {
            currentCommentIndex = 0;
            currentCommentPage = 0;
            addComment();
            state = "commentInProgress";
          } else {
            // No comments, go back to ready state
            state = "ready";
          }
        }
      } else if (state === "commentInProgress") {
        const currentCommentText = currentPostData.comments[currentCommentIndex];
        const hasMoreCommentText = (currentCommentPage + 1) * CHARS_PER_PAGE < currentCommentText.length;
        
        if (hasMoreCommentText) {
          currentCommentPage++;
          addComment();
        } else {
          // Current comment finished, move to next comment
          currentCommentIndex++;
          currentCommentPage = 0;

          if (currentCommentIndex < currentPostData.comments.length) {
            // If we've shown 6 comments, clear the screen for the next batch
            if (currentCommentIndex > 0 && currentCommentIndex % 6 === 0) {
              resetContainer();
            }
            addComment();
          } else {
            // All comments finished for this post
            resetForNewPost();
          }
        }
      }
    });
  </script>
</body>
</html>
